#!/usr/bin/env python3
#-*- coding: utf-8 -*-

# execution.py
# By Darren Yeap V1.0

from abc import ABCMeta, abstractmethod
import datetime as dt
try:
    import Queue as queue
except ImportError:
    import queue

from zetatrader.event import FillEvent, OrderEvent


class ExecutionHandler(object):
    """
    The ExecutionHandler abstract class handles the interaction
    between a set of order objects generated by a Portfolio and
    the ultimate set of Fill objects that actually occur in the
    market. 

    The handlers can be used to subclass simulated brokerages
    or live brokerages, with identical interfaces. This allows
    strategies to be backtested in a very similar manner to the
    live trading engine.
    """

    __metaclass__ = ABCMeta

    @abstractmethod
    def execute_order(self, event):
        """
        Takes an Order event and executes it, producing
        a Fill event that gets placed onto the Events queue.

        Parameters:
        event - Contains an Event object with order information.
        """
        raise NotImplementedError("Should implement execute_order()")


class SimulatedExecutionHandler(ExecutionHandler):
    """
    The simulated execution handler simply converts all order
    objects into their equivalent fill objects automatically
    without latency, slippage or fill-ratio issues.

    This allows a straightforward "first go" test of any strategy,
    before implementation with a more sophisticated execution
    handler.
    """
    
    def __init__(self, events):
        """
        Initialises the handler, setting the event queues
        up internally.

        Parameters:
        events - The Queue of Event objects.
        """
        self.events = events
    
    def __str__(self):
        """
        Prints the name of this strategy
        """
        return "SimulatedExecutionHandler"

    def execute_order(self, event):
        """
        Simply converts Order objects into Fill objects naively,
        i.e. without any latency, slippage or fill ratio problems. 
        Under the backtest and portfolio infrastructure, the order
        event is only recieved at new bar following the signal bar. 
        Hence, if it is a market bar, we the executed price for a
        'MKT' order is the open price and 'LIMIT' order as the 
        limit price itself.

        Parameters:
        event - Contains an Event object with order information.
        """
        if event.type == 'ORDER':
            fill_event = FillEvent(
                dt.datetime.utcnow()
                , event.symbol,
                'Exchange_Name'
                , event.quantity
                , event.direction
                , fill_cost = None
                , commission=1
            )
            self.events.put(fill_event)


class BetterSimulatedExecutionHandler(ExecutionHandler):
    """
    The simulated execution handler simply converts all order
    objects into their equivalent fill objects automatically
    without latency or fill-ratio issues. However, it factors in 
    slippage in the form of using next bars open price as the
    filled price. This allows for more accurate representation 
    of slippage especially for low frequency strategies such 
    as daily, weekly, or monthly bars.  

    This is an alternative "first go" test of any strategy,
    before implementation with a more sophisticated execution
    handler.
    """

    def __init__(self, events, bars = None):
        """
        Initialises the handler, setting the event queues
        up internally.

        Parameters:
        events - The Queue of Event objects.
        bars - The datahandler object
        """
        self.events = events
        self.bars = bars

        if bars is None:
            print("Data Handler not inserted into Execution Handler")
    
    def __str__(self):
        """
        Prints the name of this strategy
        """
        return "BetterSimulatedExecutionHandler"

    def execute_order(self, event):
        """
        Converts Order objects into Fill objects without any latency
        or fill ratio problems. Calls a function within the 
        data handler for the next open price and insert that as the 
        fill_cost. A fill event contains: fill time, symbol, exchange
        name, quantity, direction, fill price/cost, commission. 

        Parameters:
        event - Contains an Event object with order information.
        """
        if event.type == 'ORDER':
            fill_cost = None
            timeindex = None
            try:
                fill_cost = self.bars.get_next_open_price(event.symbol)
                timeindex = self.bars.get_latest_bar_datetime(event.symbol)
            except:
                print("%s Order Not Filled" %event.symbol)
            else:
                fill_event = FillEvent(
                    timeindex
                    , event.symbol
                    , "BACKTEST EXCHANGE"
                    , event.quantity
                    , event.direction
                    , fill_cost
                    , commission=1
                )
                self.events.put(fill_event)




